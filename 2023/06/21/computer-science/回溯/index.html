<!-- build time:Thu May 09 2024 15:33:33 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="A Simple Blog" href="/rss.xml"><link rel="alternate" type="application/atom+xml" title="A Simple Blog" href="/atom.xml"><link rel="alternate" type="application/json" title="A Simple Blog" href="/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="2023/06/21/computer-science/回溯/"><title>回溯解决子集、组合和全排列系列问题 - 计算机科学 | ColaHub = A Simple Blog</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">回溯解决子集、组合和全排列系列问题</h1><div class="meta"><span class="item" title="创建时间：2023-06-21 22:33:26"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-06-21T22:33:26+08:00">2023-06-21</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>6k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>5 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">ColaHub</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://imgbed-1303886329.cos.ap-nanjing.myqcloud.com/img(5).webp"></li><li class="item" data-background-image="https://imgbed-1303886329.cos.ap-nanjing.myqcloud.com/img(20).webp"></li><li class="item" data-background-image="https://imgbed-1303886329.cos.ap-nanjing.myqcloud.com/img(19).webp"></li><li class="item" data-background-image="https://imgbed-1303886329.cos.ap-nanjing.myqcloud.com/img(11).webp"></li><li class="item" data-background-image="https://imgbed-1303886329.cos.ap-nanjing.myqcloud.com/img(16).webp"></li><li class="item" data-background-image="https://imgbed-1303886329.cos.ap-nanjing.myqcloud.com/img(4).webp"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="2023/06/21/computer-science/回溯/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar1.jpg"><meta itemprop="name" content="colagold"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="A Simple Blog"></span><div class="body md" itemprop="articleBody"><h1 id="回溯"><a class="anchor" href="#回溯">#</a> 回溯</h1><p>回溯是一种算法思想，可由递归实现。递归是一种解决问题的方法，而回溯是一种特定的算法实现。递归是通过调用自身来解决问题的一种策略，而回溯是在解空间中进行搜索并进行选择的算法。</p><p><strong>为什么要介绍定义？</strong><br>因为之前一直将递归当成回溯，这是个错误的思想。递归的范围会更大，其囊括了回溯。</p><h1 id="回溯思想"><a class="anchor" href="#回溯思想">#</a> 回溯思想</h1><p>解决回溯问题，实际上就是一个决策树的遍历过程，只需要思考如下三个问题：</p><ol><li>路径：就是已经做出的选择。</li><li>选择列表：也就是当前可以做出的选择</li><li>结束条件：要么满足要求，要么已经遍历结束。</li></ol><p><strong>框架</strong><br></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result=[]</span><br><span class="line">def backtrack(选择列表,路径):</span><br><span class="line">    if 满足结束条件：</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line">    for 选择 in 选择列表：</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(选择列表，路径)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><br>在回溯算法中，撤销选择是为了回到上一步并尝试其他的选择。当我们进行回溯时，可能会发现当前的选择不满足问题的约束条件或无法得到最终的解。这时，我们需要撤销当前的选择，回到上一步进行其他的尝试。<p></p><h1 id="经典例题"><a class="anchor" href="#经典例题">#</a> 经典例题</h1><h2 id="1-入门"><a class="anchor" href="#1-入门">#</a> 1 入门</h2><h3 id="11-全排列"><a class="anchor" href="#11-全排列">#</a> 1.1 全排列</h3><p>仓库代码：<a href="%E5%85%A8%E6%8E%92%E5%88%97.py">全排列</a></p><p>力扣地址：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMvZGVzY3JpcHRpb24v">46. 全排列</span></p><p><strong>题目描述</strong></p><p>给定一个不含重复数字的数组 nums，返回其所有可能的全排列。</p><p></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p></p><p><strong>套用模板的代码：</strong><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self,nums</span>):</span><br><span class="line">    res=[]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">candidates,select</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(candidates)==<span class="built_in">len</span>(select):</span><br><span class="line">            res.append(select[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> candidate <span class="keyword">in</span> candidates:</span><br><span class="line">            <span class="keyword">if</span> candidate <span class="keyword">in</span> select:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            select.append(candidate)</span><br><span class="line">            backtrack(candidates,select)</span><br><span class="line">            select.pop()</span><br><span class="line">    select=[]</span><br><span class="line">    backtrack(nums,select)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p></p><p><strong>解释</strong></p><ul><li><strong>终止条件</strong>：根据题目要求，其返回的是全排列的所有可能结果，对于每一个结果都会包含题目所给的所有元素。因此需要选择完所有的元素再终止。</li><li><strong>路径与选择</strong><br><img data-src="https://imgbed-1303886329.cos.ap-nanjing.myqcloud.com/20230609222736.png" alt=""><br>上图对应着路径与选择阶段<ul><li>if 语句的作用是判断已排列的元素中是否含有当前元素，全排列是不允许已经被选择的元素再进入。而且题目要求说明了所给数字是不重复的，所以只需要判定已经参与的不再参与就行。后续会介绍所给是有重复的该如何处理。</li><li>进入 for 循环则进入选择阶段，对于第一个 candidate (1)，先判断之前是否参与选择，如果没参与则会将 1 加入选择的列表，选择完后，再进入 backtrack 函数，进行 1 之后的元素选择【这个时候 if 判断就发挥作用了，candidate (1) 将不会被选择，而去选择剩余元素】。</li><li>当递归结束后，也就得到了排列为 1 开头的所有全排列。此时需要从选择里面删除 1，进入下一个 for 循环，对 2 进行搜索。</li></ul></li></ul><h2 id="元素无重不可复选"><a class="anchor" href="#元素无重不可复选">#</a> 元素无重不可复选</h2><h3 id="子集"><a class="anchor" href="#子集">#</a> 子集</h3><p>力扣地址：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzL2Rlc2NyaXB0aW9uLw==">78. 子集</span></p><p><strong>题目描述</strong></p><p>给你一个整数数组 nums，数组中的元素互不相同 。返回该数组所有可能的子集 (幂集) 解集。不能包含重复的子集。你可以按任意顺序返回解集。</p><p></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p></p><p><strong>题目理解</strong></p><p>ps: 借别人的图一用，懒得画图<br>思路：按顺序取，只取当前元素后面的元素，即当前元素后面的元素构成候选集。<br>从根节点开始，题目要求是求子集，先从元素最少的子集开始，也就是空集开始，接下来是空集的子节点。在子节点做选择的时候，可选择的列表有 [1,2,3]。</p><ul><li>第一个子节点，选择 1，然后进行递归，在 [1] 的基础上，生成元素为 2 的子集，这个时候能选择的列表有 [2,3]。所以能够生成两个元素个数为 2 的子集。</li><li>在上述生成的子节点的基础上在做选择，因此 [1,2] 可做的选择只有 [3]，生成了 [1,2,3]。[1,3] 的当前元素是 3，3 后面没有新的元素，所以不产生新的子集。<br><img data-src="https://imgbed-1303886329.cos.ap-nanjing.myqcloud.com/20230621175526.png" alt=""></li></ul><p><strong>因此代码上需要通过下标来遍历，让下标一直往后移动，直到循环退出</strong></p><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res=[]</span><br><span class="line">        select=[]</span><br><span class="line">        end=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums,start</span>):</span><br><span class="line">            res.append(select[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,end):</span><br><span class="line">                select.append(nums[i])</span><br><span class="line">                backtrack(nums,i+<span class="number">1</span>)</span><br><span class="line">                select.pop()</span><br><span class="line">        backtrack(nums,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p></p><h3 id="组合"><a class="anchor" href="#组合">#</a> 组合</h3><p>力扣地址：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbnMvZGVzY3JpcHRpb24v">77. 组合</span></p><p><strong>题目描述</strong></p><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按任何顺序返回答案。</p><p></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><p><strong>题目理解</strong></p><p>该题与子集的不同之处就在于，对子集的长度进行了要求，因此我们只需要在求子集的基础上加上长度判断即可。</p><p>核心思想依旧是将可选择列表当成有序的，只选择未被选择的元素</p><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res=[]</span><br><span class="line">        select=[]</span><br><span class="line">        nums=[i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums,start</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(select)==k:</span><br><span class="line">                res.append(select[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,n):</span><br><span class="line">                select.append(nums[i])</span><br><span class="line">                backtrack(nums,i+<span class="number">1</span>)</span><br><span class="line">                select.pop()</span><br><span class="line">        backtrack(nums,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p></p><h2 id="元素可重不可复选"><a class="anchor" href="#元素可重不可复选">#</a> 元素可重不可复选</h2><h3 id="子集ii"><a class="anchor" href="#子集ii">#</a> 子集 II</h3><p>力扣地址:<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzLWlpL2Rlc2NyaXB0aW9uLw==">90. 子集 II</span></p><p><strong>题目描述</strong></p><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。 解集不能包含重复的子集。返回的解集中，子集可以按任意顺序排列。</p><p></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure><p></p><p><strong>题目解释</strong></p><p>ps：继续借图<br>因为有重复元素，所以首先排序，让重复元素变成相邻的元素，再对其进行预剪枝。需要结合代码理解。</p><ul><li>剪枝有两个条件， <code>i&gt;start and nums[i]==nums[i-1]</code> ，其中 <code>i&gt;start</code> 是保证不会删除如图所示的 [1,2] 后面的子节点 [1,2,2]。 <code>num[i]==num[i-1]</code> 是需要在前置条件满足的情况下，剪去相邻重复树枝，而不剪去子节点</li></ul><p><img data-src="https://imgbed-1303886329.cos.ap-nanjing.myqcloud.com/20230621193544.png" alt=""></p><p><strong>代码</strong><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res=[]</span><br><span class="line">        select=[]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums,start</span>):</span><br><span class="line">            res.append(select[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;start <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>]: <span class="comment">#剪枝</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                select.append(nums[i])</span><br><span class="line">                backtrack(nums,i+<span class="number">1</span>)</span><br><span class="line">                select.pop()</span><br><span class="line">        backtrack(nums,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p></p><h3 id="组合总和ii"><a class="anchor" href="#组合总和ii">#</a> 组合总和 II</h3><p>力扣地址：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taWkvZGVzY3JpcHRpb24v">组合总和 II</span></p><p><strong>题目描述</strong></p><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。<br>注意：解集不能包含重复的组合。</p><p></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><p><strong>题目解释</strong></p><p>该题中也是包含重复元素，只需要添加一个终止条件 <code>sum(select)==target</code> 即可。</p><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res=[]</span><br><span class="line">        select=[]</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums,start</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(select)==target:</span><br><span class="line">                res.append(select[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(select)&gt;target:<span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;start <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                select.append(nums[i])</span><br><span class="line">                backtrack(nums,i+<span class="number">1</span>)</span><br><span class="line">                select.pop()</span><br><span class="line">        backtrack(candidates,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p></p><h3 id="全排列ii"><a class="anchor" href="#全排列ii">#</a> 全排列 II</h3><p>力扣链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMtaWkvZGVzY3JpcHRpb24v">47. 全排列 II</span></p><p><strong>题目描述</strong><br>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><p></p><p><strong>题目解释</strong></p><p>该题要求全排列、生成的结果不重复。采取的方案是全排列 + 预剪枝。后剪枝比较耗时。</p><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res=[]</span><br><span class="line">        nums.sort()</span><br><span class="line">        select=[]</span><br><span class="line">        used=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> nums]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(select)==<span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(select[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> used[i]==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>] <span class="keyword">and</span> used[i-<span class="number">1</span>]==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                select.append(nums[i])</span><br><span class="line">                used[i]=<span class="number">1</span></span><br><span class="line">                backtrack(nums)</span><br><span class="line">                select.pop()</span><br><span class="line">                used[i]=<span class="number">0</span></span><br><span class="line">        backtrack(nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p></p><p><strong>为什么在递归里面需要遍历所有元素？</strong><br>全排列即使你选择了中间的某个数，在接下来的递归里，仍旧有可能选择所选择的数之前的操作，所有不能使用 <code>for i in range(start,end)</code> ，这中 for 循环的使用形式只适用于求子集。</p><ul><li>在遍历所有的元素做选择之时，有一个前提条件就是已经选择过的不能再选择。对应第一个 if 条件 <code>if used[i]==1:</code></li><li><strong>处理重复项即剪枝</strong>，代码采用的是预剪枝的情况，如 <code>[1,1,3]</code> ，已经取了 1 用于生成第一棵递归树，此时 <code>used</code> 的第一个位置已经置为 <code>1</code> ，在进入递归时， <code>for</code> 循环又会去遍历数组里的所有元素，但第一个 <code>1</code> 已经被用过了，则会跳过该次选择，进而去找第二个元素 <code>1</code> ，但是此时满足 <code>i&gt;0 and nums[i]==nums[i-1] and used[i-1]==1</code> ，所以以 <code>[1,1]</code> 开头的子树将会被删除。</li><li><strong>那 1，1 开头的在哪取呢</strong>：答案是以第二个 <code>1</code> 为头节点的子树里取。这就是该代码的技巧，如果有两个元素相同，则会从第一个元素进行剪枝，而最后一个元素保留。</li></ul><h2 id="元素无重可复选"><a class="anchor" href="#元素无重可复选">#</a> 元素无重可复选</h2><h3 id="组合总和"><a class="anchor" href="#组合总和">#</a> 组合总和</h3><p>力扣链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0vZGVzY3JpcHRpb24v">组合总和</span></p><p><strong>题目描述</strong></p><p>给一个 <strong>无重复元素</strong> 的整数数组  <code>candidates</code>  和一个目标整数  <code>target</code>  ，找出  <code>candidates</code>  中可以使数字和为目标数  <code>target</code>  的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。<br><code>candidates</code>  中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p><strong>示例</strong></p><blockquote><p><strong>输入:</strong> candidates = <code>[2,3,5]</code> ,target = 8<br><strong>输出:</strong> <code>[[2,2,2,2],[2,3,3],[3,5]]</code></p></blockquote><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        res,select=[],[]</span><br><span class="line">        v=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums,start</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(select)==target:</span><br><span class="line">                res.append(select[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(select)&gt;target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,<span class="built_in">len</span>(nums)):</span><br><span class="line">                select.append(nums[i])</span><br><span class="line">                backtrack(nums,i)</span><br><span class="line">                select.pop()</span><br><span class="line">        backtrack(candidates,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p></p><p>ps: 懒得画图，借图说话</p><p><strong>思路</strong><br>如果在每次递归里面都遍历所有的元素，则会造成重复，比如 <code>[3,5],[5,3]</code> ，这个时候可以考虑求子集的思想，遍历下标，由于题目要求可以重复选，因此每次递归时都需要包含自身但不包含自己前面的元素，以达到剪枝的目的。</p><p><img data-src="https://imgbed-1303886329.cos.ap-nanjing.myqcloud.com/20231018092438.png" alt=""></p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-10-18 09:33:30" itemprop="dateModified" datetime="2023-10-18T09:33:30+08:00">2023-10-18</time> </span><span id="2023/06/21/computer-science/回溯/" class="item leancloud_visitors" data-flag-title="回溯解决子集、组合和全排列系列问题" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.jpg" alt="colagold 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.jpg" alt="colagold 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>colagold <i class="ic i-at"><em>@</em></i>A Simple Blog</li><li class="link"><strong>本文链接：</strong> <a href="2023/06/21/computer-science/%E5%9B%9E%E6%BA%AF/" title="回溯解决子集、组合和全排列系列问题">2023/06/21/computer-science/回溯/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="2023/06/19/computer-science/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;imgbed-1303886329.cos.ap-nanjing.myqcloud.com&#x2F;img(13).webp" title="MySQL事务隔离级别"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机科学</span><h3>MySQL事务隔离级别</h3></a></div><div class="item right"><a href="2023/06/27/note/%E4%BF%A12/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;imgbed-1303886329.cos.ap-nanjing.myqcloud.com&#x2F;img(13).webp" title="你就是我的光"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 风雅杂谈</span><h3>你就是我的光</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">1.</span> <span class="toc-text">回溯</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%80%9D%E6%83%B3"><span class="toc-number">2.</span> <span class="toc-text">回溯思想</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">经典例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%A5%E9%97%A8"><span class="toc-number">3.1.</span> <span class="toc-text">1 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 全排列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89"><span class="toc-number">3.2.</span> <span class="toc-text">元素无重不可复选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">3.2.2.</span> <span class="toc-text">组合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%8F%AF%E9%87%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89"><span class="toc-number">3.3.</span> <span class="toc-text">元素可重不可复选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86ii"><span class="toc-number">3.3.1.</span> <span class="toc-text">子集 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii"><span class="toc-number">3.3.2.</span> <span class="toc-text">组合总和 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97ii"><span class="toc-number">3.3.3.</span> <span class="toc-text">全排列 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%E5%8F%AF%E5%A4%8D%E9%80%89"><span class="toc-number">3.4.</span> <span class="toc-text">元素无重可复选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">3.4.1.</span> <span class="toc-text">组合总和</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="2023/06/19/computer-science/MySQL事务隔离级别/" rel="bookmark" title="MySQL事务隔离级别">MySQL事务隔离级别</a></li><li class="active"><a href="2023/06/21/computer-science/回溯/" rel="bookmark" title="回溯解决子集、组合和全排列系列问题">回溯解决子集、组合和全排列系列问题</a></li><li><a href="2023/07/10/computer-science/HTTP01/" rel="bookmark" title="HTTP响应体和请求体">HTTP响应体和请求体</a></li><li><a href="2023/10/17/computer-science/博客/" rel="bookmark" title="hexo博客使用">hexo博客使用</a></li><li><a href="2023/10/25/computer-science/吃透链表/" rel="bookmark" title="吃透链表">吃透链表</a></li><li><a href="2024/01/02/computer-science/二分查找/" rel="bookmark" title="二分查找">二分查找</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="colagold" data-src="/images/avatar1.jpg"><p class="name" itemprop="name">colagold</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="archives/"><span class="count">33</span> <span class="name">文章</span></a></div><div class="item categories"><a href="categories/"><span class="count">4</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbGFnb2xk" title="https:&#x2F;&#x2F;github.com&#x2F;colagold"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95dS1tZW5nLTY1LTUw" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yu-meng-65-50"><i class="ic i-zhihu"></i></span> <span class="exturl item about" data-url="aHR0cDovL2NvbGFnb2xkLnRvcC8yMDIzLzA2LzE1L2Fib3V0bWUv" title="http:&#x2F;&#x2F;colagold.top&#x2F;2023&#x2F;06&#x2F;15&#x2F;aboutme&#x2F;"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="2023/06/19/computer-science/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="2023/06/27/note/%E4%BF%A12/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="categories/golang/" title="分类于 Go">Go</a></div><span><a href="2024/05/08/golang/if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/" title="Go If">Go If</a></span></li><li class="item"><div class="breadcrumb"><a href="categories/golang/" title="分类于 Go">Go</a></div><span><a href="2024/05/08/golang/%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89/" title="Go 变量定义">Go 变量定义</a></span></li><li class="item"><div class="breadcrumb"><a href="categories/golang/" title="分类于 Go">Go</a></div><span><a href="2024/05/08/golang/new%E4%B8%8Emap/" title="Go new和make">Go new和make</a></span></li><li class="item"><div class="breadcrumb"><a href="categories/note/" title="分类于 风雅杂谈">风雅杂谈</a></div><span><a href="2023/06/19/note/%E8%AF%97%E8%AF%8D/" title="诗词收集">诗词收集</a></span></li><li class="item"><div class="breadcrumb"><a href="categories/golang/" title="分类于 Go">Go</a></div><span><a href="2024/05/08/golang/type%E5%85%B3%E9%94%AE%E5%AD%97/" title="Go type关键字">Go type关键字</a></span></li><li class="item"><div class="breadcrumb"><a href="categories/computer-science/" title="分类于 计算机科学">计算机科学</a></div><span><a href="2023/07/10/computer-science/HTTP01/" title="HTTP响应体和请求体">HTTP响应体和请求体</a></span></li><li class="item"><div class="breadcrumb"><a href="categories/golang/" title="分类于 Go">Go</a></div><span><a href="2024/05/08/golang/%E8%AE%BE%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/" title="Go 设置国内镜像">Go 设置国内镜像</a></span></li><li class="item"><div class="breadcrumb"><a href="categories/golang/" title="分类于 Go">Go</a></div><span><a href="2024/05/08/golang/go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" title="Go 编程规范">Go 编程规范</a></span></li><li class="item"><div class="breadcrumb"><a href="categories/golang/" title="分类于 Go">Go</a></div><span><a href="2024/05/08/golang/%E5%80%BC%E4%BC%A0%E9%80%92vs%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/" title="值传递与引用传递">值传递与引用传递</a></span></li><li class="item"><div class="breadcrumb"><a href="categories/note/" title="分类于 风雅杂谈">风雅杂谈</a></div><span><a href="2023/07/10/note/%E6%83%85%E4%B9%A601/" title="致不离不弃的你">致不离不弃的你</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">colagold @ ColaHub</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">41k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">37 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/06/21/computer-science/回溯/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->